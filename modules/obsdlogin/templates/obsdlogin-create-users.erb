#!/usr/bin/env python
#
# AUTOGENERATED BY PUPPET
# All manual changes will be overwritten
#

import argparse
import hashlib
import ldap
import os
import pwd
import re
import shlex
import subprocess
import sys
import tempfile

parser = argparse.ArgumentParser()
parser.add_argument('--check',
                    help='only check if anything will change',
                    action='store_true'
)
args = parser.parse_args()

# In check mode we only check if any changes would be made.
# Puppet expects the program to exit 0 when there are changes to be made.
check_mode = args.check

special_uids = ['ddns']

con = ldap.initialize('ldaps://<%= ldap_server %>')

con.set_option(ldap.OPT_X_TLS_DEMAND, True)

try:
  con.simple_bind_s()
except ldap.LDAPError, e:
  if type(e.message) == dict and e.message.has_key('desc'):
    print e.message['desc']
  else:
    print e
  sys.exit(1)

base_dn = 'dc=tech,dc=dreamhack,dc=se'

groupfilter = '(cn=services-<%= current_event %>)'
groupattrs = ['memberUid']

search = con.search_s(base_dn, ldap.SCOPE_SUBTREE, groupfilter, groupattrs )

admin_uids = []

for result in search:
  for uid in result[1]['memberUid']:
    admin_uids.append(uid)

admin_uids.extend(special_uids)

# Create a list of the current existing users
existing_users = []

users = pwd.getpwall()

for user in users:
    existing_users.append(user[0])

# Prepare LDAP filter that finds information for all the users
adminfilter = '(|'
for uid in admin_uids:
  adminfilter += '(uid=%s)' % uid
adminfilter += ')'

# Create users that do not already exist
new_admins = []
for uid in admin_uids:
  if uid not in existing_users:
    new_admins.append(uid)


if new_admins:

  if check_mode:
    print "There are users pending creation."
    sys.exit(0)

  for uid in new_admins:
    print 'Creating user %s' % uid

    # Using 13 asterisks for password is intentional, see passwd(5):
    # "login accounts not allowing password authentication but allowing other
    # authentication methods, for example public key authentication,
    # conventionally have 13 asterisks in the password field."
    if uid in special_uids:
      adduser_command = shlex.split('adduser -group USER -batch %s nobody %s *************' % (uid, uid))
    else:
      adduser_command = shlex.split('adduser -group USER -batch %s wheel %s *************' % (uid, uid))
    status = subprocess.call(adduser_command)

# Update authorized_keys for everyone
uidattrs = ['uid', 'sshPublicKey']

search = con.search_s(base_dn, ldap.SCOPE_SUBTREE, adminfilter, uidattrs)
for result in search:
  public_keys = []
  uid = result[1]['uid'][0]
  uid_numeric = pwd.getpwnam(uid)[3]
  for key in result[1]['sshPublicKey']:
    public_keys.append(key)

  fd, path = tempfile.mkstemp(suffix='', prefix='authorized_keys', dir='/home/%s/.ssh' % uid)
  os.chown(path, uid_numeric, uid_numeric)

  file = os.fdopen(fd, 'w')

  for line in public_keys:
    file.write('%s\n' % line)

  file.close()

  size = os.stat(path).st_size

  if size == 0:
    print "temporary file %s for user %s is empty, will not overwrite the real file" % (path, uid)
    continue

  authkeys_file = '/home/%s/.ssh/authorized_keys' % uid

  if not (os.path.isfile(authkeys_file)):
    if check_mode:
      print "An authorized_keys file will be created"
      os.remove(path)
      sys.exit(0)

    print 'Creating authorized_keys for %s' % uid
    os.rename(path, authkeys_file)

  else: 
    cur_authkeys_hash = hashlib.sha256(open(authkeys_file, 'rb').read()).hexdigest()
    tmp_authkeys_hash = hashlib.sha256(open(path, 'rb').read()).hexdigest()

    if cur_authkeys_hash != tmp_authkeys_hash:

      if check_mode:
        print "An authorized_keys file will be updated"
        os.remove(path)
        sys.exit(0)

      print 'Updating authorized_keys for %s' % uid
      os.rename(path, authkeys_file)
    else:
      # Remove unchanged temporary file
      os.remove(path)

if check_mode:
  # If we got this far in check_mode nothing will be modified, let puppet know this:
  sys.exit(1)
